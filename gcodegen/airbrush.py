"""
Airbrush-specific functionality for the H.Airbrush device.

This module contains functionality specific to the H.Airbrush dual-airbrush plotter,
including airbrush control, tool changes, and physics modeling for stroke width and opacity.
"""

import math
import logging
from typing import Dict, List, Tuple, Optional, Union

# Set up logging
logger = logging.getLogger(__name__)


class AirbrushController:
    """Controller for H.Airbrush dual-airbrush plotter."""
    
    def __init__(self, config: Dict = None):
        """Initialize airbrush controller.
        
        Args:
            config: Configuration dictionary (optional)
        """
        self.config = config or {}
        
        # Machine parameters
        self.machine_width = self.config.get("machine", {}).get("bed_size_x", 400)
        self.machine_height = self.config.get("machine", {}).get("bed_size_y", 400)
        self.machine_z_min = 0
        self.machine_z_max = 84  # Maximum Z height of the machine in mm
        
        # Z height parameters
        self.z_min = self.config.get("machine", {}).get("z_min", 5.0)
        self.z_max = self.config.get("machine", {}).get("z_max", 80.0)
        self.z_travel = self.config.get("machine", {}).get("safe_z", 10.0)
        self.safe_z_threshold = self.config.get("machine", {}).get("safe_z", 10.0)
        
        # Speed parameters
        self.travel_speed = self.config.get("machine", {}).get("travel_speed", 24000)
        self.drawing_speed = self.config.get("machine", {}).get("work_speed", 3000)
        self.z_speed = self.config.get("machine", {}).get("z_speed", 1200)
        
        # U/V axis parameters for stepper motor flow control
        self.u_axis_min = self.config.get("u_axis", {}).get("min", 0.0)
        self.u_axis_max = self.config.get("u_axis", {}).get("max", 4.0)
        self.u_axis_dead_zone = self.config.get("u_axis", {}).get("dead_zone", 0.8)
        self.u_axis_feedrate = self.config.get("u_axis", {}).get("feedrate", 200)
        
        self.v_axis_min = self.config.get("v_axis", {}).get("min", 0.0)
        self.v_axis_max = self.config.get("v_axis", {}).get("max", 4.0)
        self.v_axis_dead_zone = self.config.get("v_axis", {}).get("dead_zone", 0.8)
        self.v_axis_feedrate = self.config.get("v_axis", {}).get("feedrate", 200)
        
        # Paint flow scaling factors
        self.paint_flow_base = self.config.get("paint_flow_base", 0.1)
        self.paint_flow_max = self.config.get("paint_flow_max", 0.5)
        self.paint_flow_width_factor = self.config.get("paint_flow_width_factor", 0.05)
        self.paint_flow_opacity_factor = self.config.get("paint_flow_opacity_factor", 0.4)
        
        # Spray cone angle (for Z height calculation)
        self.spray_cone_angle = 15.0  # degrees
        self.spray_cone_factor = math.tan(math.radians(self.spray_cone_angle / 2))
        
        # Brush state tracking
        self.brush_a_active = False
        self.brush_b_active = False
        self.current_brush = None
        
        # Tool offsets
        self.head_offsets = self.config.get("machine", {}).get("head_offsets", {
            "tool0": {"x": 0, "y": 0},
            "tool1": {"x": 10, "y": 0}
        })
    
    def generate_machine_initialization(self) -> List[str]:
        """Generate G-code for machine initialization.
        
        Returns:
            List of G-code commands for machine initialization
        """
        commands = []
        
        # Add header
        commands.append("; H.Airbrush Dual-Airbrush Plotter G-code")
        commands.append("; Generated by GCodeGen")
        
        # Basic machine setup
        commands.append("M451 ; CNC mode")
        commands.append("G17 ; X-Y plane")
        commands.append("G21 ; mm units")
        commands.append("G90 ; Absolute positioning")
        commands.append("M17 ; Enable all motors")
        
        # Ensure soft limits are enforced at the start
        commands.append("M564 H1 S1 ; Enforce soft limits and require homing")
        
        # Home all axes including U and V for flow control
        skip_homing = self.config.get("machine", {}).get("skip_homing", False)
        if not skip_homing:
            commands.append("G28 ; Home X, Y, Z axes")
            commands.append("G28 U ; Home U axis (Brush A flow control)")
            commands.append("G28 V ; Home V axis (Brush B flow control)")
        
        # Raise Z to safe height
        commands.append(f"G0 Z{self.z_travel:.3f} F1200 ; Raise Z to safe height")
        commands.append("M400 ; Wait for Z movement to complete")
        commands.append(f"G92 Z{self.z_travel:.3f} ; Set Z height")
        
        # Disable stepper timeout
        commands.append("M84 S0 ; No stepper timeout")
        
        # Initialize airbrush systems
        commands.append("; ===== AIRBRUSH SYSTEM INITIALIZATION =====")
        
        # First, ensure all fans are off
        commands.append("; 1. Turn off all air solenoids")
        commands.append("M106 P2 S0 ; Brush A air off")
        commands.append("M106 P3 S0 ; Brush B air off")
        commands.append("G4 P500 ; Wait for air to stop completely")
        
        # Ensure U and V axes are at minimum position (closed)
        commands.append("; 2. Ensure U and V axes are at minimum position (closed)")
        commands.append(f"G1 U{self.u_axis_min:.3f} F{self.u_axis_feedrate} ; Close Brush A flow")
        commands.append(f"G1 V{self.v_axis_min:.3f} F{self.v_axis_feedrate} ; Close Brush B flow")
        commands.append("M400 ; Wait for stepper motion to complete")
        
        # Select Tool 0 (Brush A) as the default tool
        commands.append("; --- Tool Selection ---")
        commands.append("T0 ; Select Tool 0 (Brush A) as the default tool")
        commands.append("G4 P500 ; Wait for tool selection to complete")
        
        # Add comment about U/V axis and fan configuration
        commands.append("; STEPPER AND FAN CONFIGURATION:")
        commands.append("; - Brush A: Air=Fan2, Flow=U axis (range: 0.0-4.0mm, OFF=0.0mm, FULL ON=4.0mm)")
        commands.append("; - Brush B: Air=Fan3, Flow=V axis (range: 0.0-4.0mm, OFF=0.0mm, FULL ON=4.0mm)")
        commands.append("; - Lower 20% of travel (0.0-0.8mm) is effectively OFF (dead zone)")
        commands.append("; - U/V axis feedrate: 200 mm/min for smooth flow control")
        commands.append("; TOOL SELECTION:")
        commands.append("; - Tool 0 = Brush A (Primary Airbrush)")
        commands.append("; - Tool 1 = Brush B (Secondary Airbrush)")
        commands.append("; - Tool offsets are configured in RepRapFirmware's config.g using G10")
        commands.append("; - Switching tools automatically applies the configured offset")
        commands.append("; - Soft limits temporarily disabled when using Tool 1")
        commands.append("; SAFETY MEASURES:")
        commands.append("; - Brush activation only happens after XY positioning and Z lowering")
        commands.append("; - Using M400 to ensure all moves complete before next action")
        commands.append("; - Air turned on before paint to prevent dripping")
        commands.append("; - Paint turned off before air to prevent dripping")
        commands.append("; Z TRAVEL OPTIMIZATION:")
        commands.append(f"; - Safe Z threshold: {self.safe_z_threshold:.1f}mm")
        commands.append(f"; - Travel Z height: {self.z_travel:.1f}mm")
        commands.append("; - Z will only be raised for travel if below the safe threshold")
        commands.append("; ===== END AIRBRUSH SYSTEM INITIALIZATION =====")
        commands.append("")
        
        return commands
    
    def generate_machine_cleanup(self) -> List[str]:
        """Generate G-code for machine cleanup.
        
        Returns:
            List of G-code commands for machine cleanup
        """
        commands = []
        
        commands.append("; ===== MACHINE CLEANUP =====")
        
        # Raise Z to safe height
        commands.append(f"G0 Z{self.z_travel:.3f} F1200 ; Raise Z to safe height")
        
        # Return to home position with Tool 0 (Brush A)
        commands.append("; Return to home position with Tool 0")
        commands.append("T0 ; Select Tool 0 (Brush A)")
        commands.append("G4 P500 ; Wait for tool change to complete")
        commands.append("G0 X0 Y0 F24000")  # X/Y max speed: 24000
        commands.append("M400 ; Wait for movement to complete")
        
        # Ensure soft limits are enforced
        commands.append("M564 H1 S1 ; Enforce soft limits")
        
        # Ensure all airbrush systems are off
        commands.append("; Turn off all airbrush systems")
        
        # Close paint flow first (U/V axes to minimum position)
        commands.append("; Close paint flow first")
        commands.append(f"G1 U{self.u_axis_min:.3f} F{self.u_axis_feedrate} ; Close Brush A flow")
        commands.append(f"G1 V{self.v_axis_min:.3f} F{self.v_axis_feedrate} ; Close Brush B flow")
        commands.append("M400 ; Wait for stepper motion to complete")
        
        # Turn off air last
        commands.append("; Turn off air after paint flow is stopped")
        commands.append("M106 P2 S0 ; Brush A air off")
        commands.append("M106 P3 S0 ; Brush B air off")
        commands.append("G4 P500 ; Allow air to stop completely")
        
        # Disable all motors to prevent overheating
        commands.append("M18 ; Disable all motors")
        
        # Final comment
        commands.append("; End of G-code")
        
        return commands
    
    def start_brush(self, brush_id: str) -> List[str]:
        """Generate G-code to start a specific brush.
        
        Args:
            brush_id: The brush ID ('A' or 'B')
            
        Returns:
            List of G-code commands to start the brush
        """
        if brush_id not in ['A', 'B']:
            raise ValueError(f"Invalid brush_id: {brush_id}. Must be 'A' or 'B'.")
        
        commands = []
        
        # Add comments for clarity
        commands.append(f"; START BRUSH {brush_id}")
        
        # Get brush-specific parameters
        if brush_id == 'A':
            tool_number = 0  # Tool 0 for Brush A
        else:  # brush_id == 'B'
            tool_number = 1  # Tool 1 for Brush B
        
        # Raise Z to safe height before tool change
        commands.append(f"G0 Z{self.z_travel:.3f} F1200 ; Raise Z to safe height before tool change")
        commands.append("M400 ; Wait for Z movement to complete")
        
        # Select the appropriate tool
        commands.append(f"T{tool_number} ; Select Tool {tool_number} (Brush {brush_id})")
        commands.append("G4 P500 ; Wait for tool change to complete")
        
        # For Tool 1 (Brush B), temporarily disable soft limits to allow movement with offset
        if brush_id == 'B':
            commands.append("M564 H0 S0 ; Disable soft limits for Tool 1 movements")
            commands.append("G4 P100 ; Brief pause after changing limits")
            commands.append("; IMPORTANT: Next XY move will apply the tool offset automatically")
        
        # Mark brush as active
        if brush_id == 'A':
            self.brush_a_active = True
            self.current_brush = 'A'
        else:
            self.brush_b_active = True
            self.current_brush = 'B'
        
        return commands
    
    def activate_brush_at_position(self, brush_id: str, paint_flow: float) -> List[str]:
        """Generate G-code to activate the brush at the current position.
        
        Args:
            brush_id: The brush ID ('A' or 'B')
            paint_flow: Paint flow value (0.0-1.0)
            
        Returns:
            List of G-code commands to activate the brush
        """
        if brush_id not in ['A', 'B']:
            raise ValueError(f"Invalid brush_id: {brush_id}. Must be 'A' or 'B'.")
        
        commands = []
        
        # Get brush-specific parameters
        if brush_id == 'A':
            axis = 'U'  # U axis for Brush A
            air_fan = 2
            axis_min = self.u_axis_min
            axis_max = self.u_axis_max
            axis_dead_zone = self.u_axis_dead_zone
            axis_feedrate = self.u_axis_feedrate
        else:  # brush_id == 'B'
            axis = 'V'  # V axis for Brush B
            air_fan = 3
            axis_min = self.v_axis_min
            axis_max = self.v_axis_max
            axis_dead_zone = self.v_axis_dead_zone
            axis_feedrate = self.v_axis_feedrate
        
        # Calculate paint flow position based on paint_flow (0-1)
        # Map from 0-1 range to dead_zone-max range
        flow_position = axis_dead_zone + (paint_flow * (axis_max - axis_dead_zone))
        # Ensure we're within valid range
        flow_position = min(max(flow_position, axis_min), axis_max)
        
        # Turn on air FIRST (no delay needed)
        commands.append(f"; AIR ON FIRST - Important to prevent dripping")
        commands.append(f"M106 P{air_fan} S1 ; Brush {brush_id} air on")
        # No G4 delay after air ON
        
        # Move stepper to flow position AFTER air is on
        commands.append(f"; PAINT ON AFTER AIR")
        commands.append(f"G4 P50 ; Short delay before stepper command")
        commands.append(f"G1 {axis}{flow_position:.3f} F{axis_feedrate} ; Set Brush {brush_id} flow to {flow_position:.3f}mm")
        commands.append(f"M400 ; Wait for stepper motion to complete")
        
        return commands
    
    def stop_brush(self, brush_id: str) -> List[str]:
        """Generate G-code to stop a specific brush.
        
        Args:
            brush_id: The brush ID ('A' or 'B')
            
        Returns:
            List of G-code commands to stop the brush
        """
        if brush_id not in ['A', 'B']:
            raise ValueError(f"Invalid brush_id: {brush_id}. Must be 'A' or 'B'.")
        
        commands = []
        
        # Add comments for clarity
        commands.append(f"; STOP BRUSH {brush_id}")
        
        # Get brush-specific parameters
        if brush_id == 'A':
            axis = 'U'  # U axis for Brush A
            air_fan = 2
            axis_min = self.u_axis_min
            axis_feedrate = self.u_axis_feedrate
        else:  # brush_id == 'B'
            axis = 'V'  # V axis for Brush B
            air_fan = 3
            axis_min = self.v_axis_min
            axis_feedrate = self.v_axis_feedrate
        
        # Move stepper to closed position first (stop paint flow)
        commands.append(f"G4 P50 ; Short delay before stepper command")
        commands.append(f"G1 {axis}{axis_min:.3f} F{axis_feedrate} ; Close Brush {brush_id} flow")
        commands.append(f"M400 ; Wait for stepper motion to complete")
        
        # Turn off air after paint flow is stopped (no delay needed)
        commands.append(f"M106 P{air_fan} S0 ; Brush {brush_id} air off")
        
        # If stopping Brush B, restore soft limits
        if brush_id == 'B':
            # Raise Z to safe height before restoring limits
            commands.append(f"G0 Z{self.z_travel:.3f} F1200 ; Raise Z to safe height before restoring limits")
            commands.append("M400 ; Wait for Z movement to complete")
            commands.append("M564 H1 S1 ; Restore soft limits after using Tool 1")
            commands.append("G4 P100 ; Brief pause after changing limits")
        else:
            # For Brush A, raise Z to safe height
            commands.append(f"G0 Z{self.z_travel:.3f} F1200 ; Raise Z to safe height after stopping brush")
            commands.append("M400 ; Wait for Z movement to complete")
        
        # Mark brush as inactive
        if brush_id == 'A':
            self.brush_a_active = False
        else:
            self.brush_b_active = False
        
        # Clear current brush
        self.current_brush = None
        
        return commands
    
    def calculate_airbrush_parameters(self, stroke_width: float, stroke_opacity: float, base_feedrate: Optional[float] = None) -> Tuple[float, float, float]:
        """Calculate optimal Z-height, paint flow, and feedrate based on stroke width and opacity.
        
        This model accounts for the physics of airbrush operation:
        1. Conical spray pattern where distance affects both width and density
        2. Paint flow control affects color intensity independently of width
        3. Movement speed affects saturation (slower = more paint in one area)
        
        Args:
            stroke_width: Desired stroke width in mm
            stroke_opacity: Desired stroke opacity (0.0-1.0)
            base_feedrate: Base feedrate in mm/min
            
        Returns:
            Tuple of (z_height, paint_flow, feedrate)
        """
        # Use base_feedrate from config if not provided
        if base_feedrate is None:
            base_feedrate = self.config.get("base_feedrate", 1500)
        
        # Step 1: Calculate optimal Z height based on desired width
        z_from_width = stroke_width / (2 * self.spray_cone_factor)
        z_height = min(max(z_from_width, self.z_min), self.machine_z_max)
        
        # Step 2: Calculate paint flow
        # Start with baseline flow
        width_component = min(stroke_width * self.paint_flow_width_factor, 0.3)  # Max 30% from width
        opacity_component = stroke_opacity * self.paint_flow_opacity_factor     # Scale by opacity
        
        # Combine components with baseline
        paint_flow = self.paint_flow_base + width_component + opacity_component
        
        # Ensure flow stays within defined limits
        paint_flow = min(max(paint_flow, self.paint_flow_base * 0.5), self.paint_flow_max)
        
        # Clamp paint flow to a minimum of 10% for Z <= 10mm (when drawing)
        if z_height <= 10.0 and paint_flow > 0.0:
            paint_flow = max(paint_flow, 0.10)
        
        # Step 3: Calculate feedrate
        # Z-based scaling (configurable exponent)
        z_exponent = self.config.get("feedrate_z_exponent", 1.2)
        z_factor = (self.z_min / z_height) ** z_exponent
        
        # Speed calculation - slower for higher opacity needs
        # Use quadratic curve for more natural response
        speed_min, speed_max = 0.3, 1.0   # Normalized speed factor range
        speed_factor = speed_max - (stroke_opacity**2 * (speed_max - speed_min))
        
        # Final feedrate calculation: base * z_factor * speed_factor
        feedrate = base_feedrate * z_factor * speed_factor
        feedrate_min = self.config.get("feedrate_min", 60)
        feedrate = max(feedrate, feedrate_min)
        
        return z_height, paint_flow, feedrate
    
    def generate_path_commands(self, polyline: List[Tuple[float, float]], stroke_color: str, 
                              stroke_width: float, stroke_opacity: float, 
                              base_feedrate: Optional[float] = None) -> List[str]:
        """Generate G-code commands for drawing a path with the airbrush.
        
        Args:
            polyline: List of (x, y) points
            stroke_color: Stroke color (e.g., "black", "white", "#ff0000")
            stroke_width: Stroke width in mm
            stroke_opacity: Stroke opacity (0.0-1.0)
            base_feedrate: Base feedrate in mm/min
            
        Returns:
            List of G-code commands for drawing the path
        """
        if not polyline or len(polyline) < 2:
            return ["; WARNING: Path has fewer than 2 points, skipping."]
        
        commands = []
        
        # Select tool based on stroke color
        brush_id = "A"  # Default to brush A (black)
        
        # Map common color names to brush selection
        if stroke_color.lower() in ["#ffffff", "white"]:
            brush_id = "B"  # Use brush B for white
        
        # Calculate parameters for airbrush based on stroke attributes
        z_height, paint_flow, feedrate = self.calculate_airbrush_parameters(
            stroke_width, stroke_opacity, base_feedrate
        )
        
        # Add detailed stroke information as comments
        commands.append(f"; ===== STROKE PARAMETERS =====")
        commands.append(f"; Color: {stroke_color}")
        commands.append(f"; Width: {stroke_width:.2f}mm")
        commands.append(f"; Opacity: {stroke_opacity:.2f}")
        commands.append(f"; Brush: {brush_id}")
        commands.append(f"; Z-height: {z_height:.2f}mm")
        commands.append(f"; Paint flow: {paint_flow:.2f}")
        commands.append(f"; Feedrate: {feedrate:.1f}mm/min")
        
        # Start the brush
        commands.extend(self.start_brush(brush_id))
        
        # Move to start point
        x0, y0 = polyline[0]
        commands.append(f"G0 X{x0:.3f} Y{y0:.3f} F24000")
        commands.append("M400 ; Wait for XY movement to complete")
        commands.append(f"G1 Z{z_height:.3f} F1200")
        commands.append("M400 ; Wait for Z movement to complete")
        
        # Activate brush at position
        commands.extend(self.activate_brush_at_position(brush_id, paint_flow))
        
        # Set feedrate for drawing
        commands.append(f"G1 F{feedrate:.1f}")
        
        # Draw path with XY movements only (Z remains constant)
        for x, y in polyline[1:]:
            commands.append(f"G1 X{x:.3f} Y{y:.3f}")
        
        commands.append("M400 ; Wait for drawing to complete")
        
        # Stop the brush
        commands.extend(self.stop_brush(brush_id))
        
        commands.append("; === PATH END ===\n")
        
        return commands 